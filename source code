#include<stdio.h>
#include<conio.h>
#include<math.h>
#include<stdlib.h>
#include<string.h>
void w_synch();
void synch();
void busy_waiting();
void spinlock();
void c_semaphore();
void b_semaphore();
void code();

int main()
{
	int i,j,s;
	do{
	printf("Enter your choice\n");
	printf("Enter 1 for print without synchronization\n");
	printf("Enter 2 for print with synchronization\n");
	printf("Enter 3 for print in busy waiting\n");
	printf("Enter 4 for print in spinlock\n");
	printf("Enter 5 for print in counting semaphore\n");
	printf("Enter 6 for print in binary semaphore\n");
	printf("Enter 7 for open code\n");
	printf("Enter 8 for exit\n");
	scanf("%d",&j);
	switch(j)
	{
		case 1: w_synch();
		break;
		case 2: synch();
		break ;
		case 3: busy_waiting();
		break ;
		case 4: spinlock();
		break ;
		case 5: c_semaphore();
		break ;
		case 6: b_semaphore();
		break ;
		case 7:code();
		break ;
		case 8: exit(0);
		break ;
		default: 
		printf("Wrong choice");
	}
	
}while(s);
}
void w_synch()
{
}
void synch()
{
printf("Thread synchronization or serialization, strictly defined, is the application of particular mechanisms to\n
ensure that two concurrently-executing threads or processes do not execute specific portions of a program \n
at the same time. If one thread has begun to execute a serialized portion of the program,\n 
any other thread trying to execute this portion must wait until the first thread finishes\n");

}
void busy_waiting()
{
printf("\nDefination :: In software engineering, busy-waiting or spinning is a technique in which a process repeatedly checks to see if a condition is true,");
printf("such as whether keyboard input or a lock is available");
printf("code"):


printf("#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
 
volatile int i = 0; /* i is global, so it is visible to all functions.
                       It's also marked volatile, because it
                       may change in a way which is not predictable by the compiler,
                       here from a different thread. */
 
/* f1 uses a spinlock to wait for i to change from 0. */
static void *f1(void *p)
{
    while (i==0) {
        /* do nothing - just keep checking over and over */
    } 
    printf("i's value has changed to %d.\n", i);
    return NULL;
}
 
static void *f2(void *p)
{
    sleep(60);   /* sleep for 60 seconds */
    i = 99;
    printf("t2 has changed the value of i to %d.\n", i);
    return NULL;
}
 
int main()
{
    int rc;
    pthread_t t1, t2;
 
    rc = pthread_create(&t1, NULL, f1, NULL);
    if (rc != 0) {
        fprintf(stderr,"pthread f1 failed\n");
        return EXIT_FAILURE;
    }
 
    rc = pthread_create(&t2, NULL, f2, NULL);
    if (rc != 0) {
        fprintf(stderr,"pthread f2 failed\n");
        return EXIT_FAILURE;
    }
 
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    puts("All pthreads finished.");
    return 0;
}");
}
void spinlock()
{
}
void c_semaphore()
{
}
void b_semaphore()
{
}
void code()
{
}
